# FangzhouConsistencyMessage
## 1` 一致性报文CM（Consistency Message）的实现：
### 1.1`CM设计采用以UDP为基础实现。

### 1.2`CM的最终效果应该是，A与B二者进行报文通信时，在一定时间内，二者通信不至于紊乱。

### 1.3`假设A对B发送了甲类报文，甲类报文会在A主机本地进行标记【使用报文标记表（Message Label Table）进行记录】，因为A通常需要等待B的反馈结果。这段时间，称为报文生存时间MST（Message Survival Time）。

### 1.4`假设在1.3的情形下，在“甲类报文J1”的MST内：
#### 1.4.1`如果在没有接受到B的回执报文之前----等价于【MST中，“甲类报文”依旧处于“被标记状态”】，A因为其他原因对B再发送“甲类报文J2”：
则A会拒绝发送，并将“甲类报文J2”放入缓冲报文队列BMQ（Buffered Message Queue）中。

#### 1.4.2`如果在MST内，接受到了B的回执报文：
则A不再需要等待，MST对甲类报文的标记会被取消，同时触发完成动作CA（Completion Action）

#### 1.4.3`如果超过了MST，“甲类报文J1”仍未接受到来自B主机的回复报文，则甲类报文的标记也会被取消【使用MST进行实际控制】，同时触发一致性报文的超时动作TA（Timeout Action）

### 1.5`关于缓冲报文队列BMQ
#### 1.5.1`BMQ这种数据结构与MST具有密不可分的联系，首先，BMQ要想增加实际的新的数据成员，就必然依赖于MST所记录的某类报文要处于被标记的状态。
#### 1.5.2`同时，当MST对某类报文的标记将要被取消的时候，必须查询BMQ，从而查询是否有被滞留的缓冲报文（Buffered Message），从而自动重新执行发送操作。
#### 1.5.3`缓冲报文BM的结构如下【ip<目的IP>，port<目的端口>，data<报文内容>】

### 1.6`关于动作的结构
#### 1.6.1·动作一定是一个函数
#### 1.6.2`完成动作CA，一定是一个带参函数，参数是接受方反馈给我们的报文内容，在这里，我们将参数本身以cont代替
#### 1.6.3`超时动作TA，我们在这里设它为无参函数。

### 1.7`关于接收器（Receiver）
接收器是接收方接受到某类报文后的一种处理方式，每一个接收器都对应一个接收器的接受动作（Receive Action），接收方一般的功能是给予发送方一些回复，当然有些也可以不给予回复。这个可以灵活搭配。接收方如果要给予回复信息，则这里的接受动作不再进行差错控制。

## 2`API调用如下
//创建甲类报文 参数分别为：甲类报文名，甲类完成动作，甲类超时动作，甲类生存时间
CM.createMessage("jia",jiaCA,jiaTA,jiaMST);
//发送报文 参数分别为：报文类名，目标IP，目标端口，发送数据
CM.sendMessage("jia",desIP,desPort,data);
//创建接受器 参数分别为：甲类报文名，接受函数
CM.createReceiver("jia",jiaRA);
