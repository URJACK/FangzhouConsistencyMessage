# FangzhouConsistencyMessage
## 1`介绍
**一致性报文CM**(Consistency Message)的实现：

### 1.1`实现基础
CM设计采用以UDP为基础实现。

### 1.2`实现效果
CM的最终效果应该是，A与B二者进行报文通信时，在一定时间内，二者通信不至于紊乱。

### 1.3`报文标记表与报文生存时间
假设A对B发送了甲类报文，甲类报文会在A主机本地进行标记【使用**报文标记表MLT**（Message Label Table）进行记录】，因为A通常需要等待B的反馈结果。这段时间，称为**报文生存时间MST**（Message Survival Time）。

### 1.4`缓冲报文队列、完成动作与超时动作
假设在1.3的情形下，在“甲类报文J1”的MST内：
#### 1.4.1`情形一
如果在没有接受到B的回执报文之前----等价于【MST中，“甲类报文”依旧处于“被标记状态”】，A因为其他原因对B再发送“甲类报文J2”：
则A会拒绝发送，并将“甲类报文J2”放入**缓冲报文队列BMQ**（Buffered Message Queue）中。

#### 1.4.2`情形二
如果在MST内，接受到了B的回执报文：
则A不再需要等待，MST对甲类报文的标记会被取消，同时触发**完成动作CA**（Completion Action）

#### 1.4.3`情形三
如果超过了MST，“甲类报文J1”仍未接受到来自B主机的回复报文，则甲类报文的标记也会被取消【使用MST进行实际控制】，同时触发一致性报文的**超时动作TA**（Timeout Action）

### 1.5`关于缓冲报文队列BMQ
#### 1.5.1`缓冲报文队列与报文标记表的联系
BMQ这种数据结构与MST具有密不可分的联系，首先，BMQ要想增加实际的新的数据成员，就必然依赖于MST所记录的某类报文要处于被标记的状态。

同时，当MST对某类报文的标记将要被取消的时候，必须查询BMQ，从而查询是否有被滞留的缓冲报文（Buffered Message），从而自动重新执行发送操作。
#### 1.5.2`缓冲报文BM
缓冲报文BM的结构如下

【ip<目的IP>，port<目的端口>，data<报文内容>】

### 1.6`关于“动作”的结构设计
#### 1.6.1·动作一定是一个函数
#### 1.6.2`完成动作CA
一个带参函数，参数是接受方反馈给我们的报文内容，在这里，我们将参数本身以data代替
#### 1.6.3`超时动作TA
一个无参函数。
#### 1.6.4`接受动作RA
一个带参函数，参数是发送方发送给我们的报文内容，在这里，我们将参数本身以data代替

### 1.7`关于接收器（Receiver）
接收器是接收方接受到某类报文后的一种处理方式，每一个接收器都对应一个接收器的**接受动作RA**（Receive Action），接收方一般的功能是给予发送方一些回复，当然有些也可以不给予回复。这个可以灵活搭配。接收方如果要给予回复信息，则这里的接受动作不再进行差错控制。

## 2`API调用如下
//创建甲类报文

参数分别为：甲类报文名，甲类完成动作，甲类超时动作，甲类生存时间

CM.createMessage("jia",jiaCA,jiaTA,jiaMST);

//发送报文 参数分别为：报文类名，目标IP，目标端口，发送数据

CM.sendMessage("jia",desIP,desPort,data);

//创建接受器 参数分别为：甲类报文名，接受函数

CM.createReceiver("jia",jiaRA);
